# -*- coding: utf-8 -*-
"""CapstoneProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QA4ohZleTaCDBGDh1fJS90LWkrKTzDml

# Dynamic Pricing for Urban Parking Lots
"""


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime
from datetime import datetime
import pathway as pw
import panel as pn
import time

df = pd.read_csv('dataset.csv')
df.head()



df['IsSpecialDay'].astype(int)

df.head()

def linearModel(prev_price, occ_rate, queueNorm, alpha=3, beta=0.8, gamma=1):
    change = alpha * (occ_rate - 0.5)
    queueBoost = beta if queueNorm > 0.5 else 0
    decay = gamma if occ_rate < 0.3 else 0
    price = prev_price + change + queueBoost - decay
    return round(min(20, max(5, price)), 2)

def demandBasedModel(occ_rate, base_price, TrafficConditionNorm, VehicleTypeNorm, queueNorm, special):
    demand = (
        0.35 * occ_rate +
        0.25 * queueNorm +
        0.10 * TrafficConditionNorm +
        0.15 * special +
        0.10 * VehicleTypeNorm
    )
    multiplier = 0.5 + (1.5 / (1 + np.exp(-5 * (demand - 0.5))))
    price = base_price * multiplier
    return round(min(20, max(5, price)), 2)

modelNumber = 2  # Set to 1 for linear model, 2 for sigmoid model
base_price = 10

# --- Schema for raw CSV ---
class ParkingEvent(pw.Schema):
    ID: int
    SystemCodeNumber: str
    Capacity: int
    Latitude: float
    Longitude: float
    Occupancy: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    LastUpdatedDate: str
    LastUpdatedTime: str

# --- Feature Encoders ---
@pw.udf
def make_timestamp(date: str, time: str) -> str:
    return f"{date} {time}"

@pw.udf
def encode_vehicle_type(vehicle: str) -> float:
    return {"cycle": 0.2, "bike": 0.4, "car": 1.0, "truck": 1.5}.get(vehicle, 1.0) / 1.5

@pw.udf
def encode_traffic(traffic: str) -> float:
    return {"low": 0, "average": 0.5, "high": 1}.get(traffic, 0.5)

@pw.udf
def normalize_queue(queue: int) -> float:
    return min(queue / 10, 1)

@pw.udf
def normalize_occupancy(occupancy: int, capacity: int) -> float:
    return occupancy / capacity

# --- Ingest CSV ---
parking_stream = pw.io.csv.read(
    "dataset.csv",
    schema=ParkingEvent,
    mode="streaming"
)

# --- Add Engineered Columns ---
parking_stream = parking_stream.select(
    **parking_stream,
    TimeStamp=make_timestamp(pw.this.LastUpdatedDate, pw.this.LastUpdatedTime),
    OccupancyRate=normalize_occupancy(pw.this.Occupancy, pw.this.Capacity),
    queueNorm=normalize_queue(pw.this.QueueLength),
    VehicleTypeNorm=encode_vehicle_type(pw.this.VehicleType),
    TrafficConditionNorm=encode_traffic(pw.this.TrafficConditionNearby)
)

# --- Final pricing logic ---
@pw.udf
def compute_dynamic_price(OccupancyRate, queueNorm, TrafficConditionNorm, special, VehicleTypeNorm, timestamp, base_price=10):
    if modelNumber == 1:
        return linearModel(base_price, OccupancyRate, queueNorm)
    else:
        return demandBasedModel(OccupancyRate, base_price, TrafficConditionNorm, VehicleTypeNorm, queueNorm, special)

# --- Select and compute final output ---
priced_output = parking_stream.select(
    SystemCodeNumber=pw.this.SystemCodeNumber,
    TimeStamp=pw.this.TimeStamp,
    Price=compute_dynamic_price(
        pw.this.OccupancyRate,
        pw.this.queueNorm,
        pw.this.TrafficConditionNorm,
        pw.this.IsSpecialDay,
        pw.this.VehicleTypeNorm,
        pw.this.TimeStamp
    )
)

# --- Write to file ---
pw.io.csv.write(priced_output, "pathway_output_prices.csv")

# --- Run Pathway ---
pw.run()

